# Generated by Hype
require 'C:/Users/ACER/Desktop/AI Planning - Assignment/Planning/HyperTensioN/Hypertension'

module Snake
  include Hypertension
  extend self

  #-----------------------------------------------
  # Domain
  #-----------------------------------------------

  @domain = {
    # Operators
    :strike => true,
    :move_short => true,
    :move_long => true,
    # Methods
    :hunt => [
      :hunt_hunt_all,
      :hunt_hunt_done
    ],
    :move => [
      :move_move_base,
      :move_move_long_snake,
      :move_move_short_snake
    ]
  }

  #-----------------------------------------------
  # Operators
  #-----------------------------------------------

  def strike(_snake, _headpos, _foodpos)
    return unless SNAKE.include?(_snake)
    return unless LOCATION.include?(_headpos)
    return unless LOCATION.include?(_foodpos)
    return unless @state[HEAD].include?([_snake, _headpos])
    return unless @state[MOUSE_AT].include?(_foodpos)
    return unless ADJACENT.include?([_foodpos, _headpos])
    return if _headpos == _foodpos
    @state = @state.dup
    (@state[MOUSE_AT] = @state[MOUSE_AT].dup).delete(_foodpos)
    (@state[HEAD] = @state[HEAD].dup).delete([_snake, _headpos])
    (@state[CONNECTED] = @state[CONNECTED].dup).unshift([_snake, _foodpos, _headpos])
    @state[HEAD].unshift([_snake, _foodpos])
    true
  end

  def move_short(_snake, _nextpos, _snakepos)
    return unless SNAKE.include?(_snake)
    return unless LOCATION.include?(_nextpos)
    return unless LOCATION.include?(_snakepos)
    return unless @state[HEAD].include?([_snake, _snakepos])
    return unless @state[TAIL].include?([_snake, _snakepos])
    return unless ADJACENT.include?([_nextpos, _snakepos])
    return if @state[OCCUPIED].include?(_nextpos)
    @state = @state.dup
    (@state[HEAD] = @state[HEAD].dup).delete([_snake, _snakepos])
    (@state[TAIL] = @state[TAIL].dup).delete([_snake, _snakepos])
    (@state[OCCUPIED] = @state[OCCUPIED].dup).delete(_snakepos)
    @state[OCCUPIED].unshift(_nextpos)
    @state[HEAD].unshift([_snake, _nextpos])
    @state[TAIL].unshift([_snake, _nextpos])
    true
  end

  def move_long(_snake, _nextpos, _headpos, _bodypos, _tailpos)
    return unless SNAKE.include?(_snake)
    return unless LOCATION.include?(_nextpos)
    return unless LOCATION.include?(_headpos)
    return unless LOCATION.include?(_bodypos)
    return unless LOCATION.include?(_tailpos)
    return unless @state[HEAD].include?([_snake, _headpos])
    return unless @state[CONNECTED].include?([_snake, _bodypos, _tailpos])
    return unless @state[TAIL].include?([_snake, _tailpos])
    return unless ADJACENT.include?([_nextpos, _headpos])
    return unless ADJACENT.include?([_bodypos, _tailpos])
    return if @state[OCCUPIED].include?(_nextpos)
    return if _bodypos == _nextpos or _tailpos == _nextpos or _headpos == _tailpos
    @state = @state.dup
    (@state[HEAD] = @state[HEAD].dup).delete([_snake, _headpos])
    (@state[TAIL] = @state[TAIL].dup).delete([_snake, _tailpos])
    (@state[CONNECTED] = @state[CONNECTED].dup).delete([_snake, _bodypos, _tailpos])
    (@state[OCCUPIED] = @state[OCCUPIED].dup).delete(_tailpos)
    @state[HEAD].unshift([_snake, _nextpos])
    @state[TAIL].unshift([_snake, _bodypos])
    @state[CONNECTED].unshift([_snake, _nextpos, _headpos])
    @state[OCCUPIED].unshift(_nextpos)
    true
  end

  #-----------------------------------------------
  # Methods
  #-----------------------------------------------

  def hunt_hunt_all
    @state[HEAD].each {|_snake, _snakepos|
      next unless LOCATION.include?(_snakepos)
      next unless SNAKE.include?(_snake)
      ADJACENT.each {|_foodpos, _pos1|
        next unless LOCATION.include?(_pos1)
        next unless @state[MOUSE_AT].include?(_foodpos)
        next unless LOCATION.include?(_foodpos)
        yield [
          [:move, _snake, _snakepos, _pos1],
          [:strike, _snake, _pos1, _foodpos],
          [:hunt]
        ]
      }
    }
  end

  def hunt_hunt_done
    return if @state[MOUSE_AT].include?(:px0y0)
    return if @state[MOUSE_AT].include?(:px1y0)
    return if @state[MOUSE_AT].include?(:px2y0)
    return if @state[MOUSE_AT].include?(:px3y0)
    return if @state[MOUSE_AT].include?(:px4y0)
    return if @state[MOUSE_AT].include?(:px0y1)
    return if @state[MOUSE_AT].include?(:px1y1)
    return if @state[MOUSE_AT].include?(:px2y1)
    return if @state[MOUSE_AT].include?(:px3y1)
    return if @state[MOUSE_AT].include?(:px4y1)
    return if @state[MOUSE_AT].include?(:px0y2)
    return if @state[MOUSE_AT].include?(:px1y2)
    return if @state[MOUSE_AT].include?(:px2y2)
    return if @state[MOUSE_AT].include?(:px3y2)
    return if @state[MOUSE_AT].include?(:px4y2)
    return if @state[MOUSE_AT].include?(:px0y3)
    return if @state[MOUSE_AT].include?(:px1y3)
    return if @state[MOUSE_AT].include?(:px2y3)
    return if @state[MOUSE_AT].include?(:px3y3)
    return if @state[MOUSE_AT].include?(:px4y3)
    return if @state[MOUSE_AT].include?(:px0y4)
    return if @state[MOUSE_AT].include?(:px1y4)
    return if @state[MOUSE_AT].include?(:px2y4)
    return if @state[MOUSE_AT].include?(:px3y4)
    return if @state[MOUSE_AT].include?(:px4y4)
    yield []
  end

  def move_move_base(_snake, _snakepos, _goalpos)
    return if _snakepos != _goalpos
    return unless LOCATION.include?(_goalpos)
    return unless LOCATION.include?(_snakepos)
    return unless SNAKE.include?(_snake)
    yield []
  end

  def move_move_long_snake(_snake, _snakepos, _goalpos)
    return unless SNAKE.include?(_snake)
    return unless LOCATION.include?(_goalpos)
    return unless LOCATION.include?(_snakepos)
    @state[CONNECTED].each {|_snake_ground, _bodypos, _tailpos|
      next if _snake_ground != _snake
      next unless @state[TAIL].include?([_snake, _tailpos])
      next unless LOCATION.include?(_bodypos)
      next unless LOCATION.include?(_tailpos)
      ADJACENT.each {|_pos2, _snakepos_ground|
        next if _snakepos_ground != _snakepos
        next unless LOCATION.include?(_pos2)
        next if @state[OCCUPIED].include?(_pos2)
        yield [
          [:move_long, _snake, _pos2, _snakepos, _bodypos, _tailpos],
          [:move, _snake, _pos2, _goalpos]
        ]
      }
    }
  end

  def move_move_short_snake(_snake, _snakepos, _goalpos)
    return unless @state[TAIL].include?([_snake, _snakepos])
    return unless LOCATION.include?(_goalpos)
    return unless LOCATION.include?(_snakepos)
    return unless SNAKE.include?(_snake)
    ADJACENT.each {|_pos2, _snakepos_ground|
      next if _snakepos_ground != _snakepos
      next unless LOCATION.include?(_pos2)
      next if @state[OCCUPIED].include?(_pos2)
      yield [
        [:move_short, _snake, _pos2, _snakepos],
        [:move, _snake, _pos2, _goalpos]
      ]
    }
  end
end